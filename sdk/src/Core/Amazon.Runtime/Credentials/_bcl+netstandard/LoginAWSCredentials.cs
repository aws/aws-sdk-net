/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

using Amazon.Runtime.Credentials;
using Amazon.Runtime.Credentials.Internal;
using Amazon.Runtime.Internal;
using Amazon.Runtime.Internal.UserAgent;
using Amazon.Runtime.Internal.Util;
using Amazon.Util;
using Amazon.Util.Internal;
using System;
using System.Globalization;
using System.Threading.Tasks;

namespace Amazon.Runtime
{
    /// <summary>
    /// AWS Credentials that are resolved using AWS Signin. The initial <see cref="LoginToken"/> is generated by
    /// tooling like AWS CLI or AWS Tools for PowerShell. The Login Token is refreshed using <see cref="LoginToken.RefreshToken">RefreshToken</see>
    /// if it's <see cref="LoginToken.AccessToken">AccessToken</see> is nearing expiry or has already expired.
    /// <para>
    /// To use LoginAWSCredentials, AWSSDK.Signin package for Signin service must be added as a dependency in the application.
    /// </para>
    /// </summary>
    public class LoginAWSCredentials : RefreshingAWSCredentials
    {
        private readonly Logger _logger = Logger.GetLogger(typeof(LoginAWSCredentials));
        private readonly ILoginTokenManager _loginTokenManager;
        private static readonly LoginTokenFileCache _loginFileCache = 
                                    new LoginTokenFileCache(
                                        CryptoUtilFactory.CryptoInstance,
                                        new FileRetriever(),
                                        new DirectoryRetriever());

        /// <summary>
        /// Options to be used in the Login flow to resolve credentials.
        /// </summary>
        public LoginAWSCredentialsOptions Options { get; private set; }

        /// <summary>
        /// Constructs an LoginAWSCredentials object.
        /// </summary>
        public LoginAWSCredentials(LoginAWSCredentialsOptions options)
        {
            if (options == null)
                throw new ArgumentNullException(nameof(options));

            if (string.IsNullOrEmpty(options.LoginSession))
                throw new ArgumentNullException(nameof(options.LoginSession));

            if (string.IsNullOrEmpty(options.Region))
            {
                var defaultRegionEndpoint = FallbackRegionFactory.GetRegionEndpoint();
                if (defaultRegionEndpoint != null)
                {
                    _logger.DebugFormat("LoginAWSCredentials: {0} determined from default profile chain as {1}.", nameof(options.Region), defaultRegionEndpoint.SystemName);
                    options.Region = defaultRegionEndpoint.SystemName;
                }
                else
                {
                    throw new ArgumentNullException(nameof(options.Region));
                }
            }

            if (string.IsNullOrEmpty(options.ProfileName))
            {
                options.ProfileName = DefaultAWSCredentialsIdentityResolver.GetProfileName();
            }

            Options = options;

            FeatureIdSources.Add(UserAgentFeatureId.CREDENTIALS_LOGIN);

            _loginTokenManager = new LoginTokenManager(
                SigninServiceClientHelpers.BuildSigninClient(
                    RegionEndpoint.GetBySystemName(options.Region),
                    options.ProfileName,
                    options.ProxySettings),
                _loginFileCache
            );
        }

#if BCL
        protected override CredentialsRefreshState GenerateNewCredentials()
        {
            var loginTokenManagerGetTokenOptions = new LoginTokenManagerGetTokenOptions
            {
                LoginSession = Options.LoginSession,
                Region = Options.Region,
                ProxySettings = Options.ProxySettings
            };

            var loginToken = _loginTokenManager.GetToken(loginTokenManagerGetTokenOptions);
            if (loginToken == null)
            {
                throw new InvalidOperationException("Login Token not found. Please reauthenticate.");
            }

            _logger.DebugFormat("AWS Login credentials found that expire at {0}", loginToken.AccessToken.ExpiresAt.Value.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK", CultureInfo.InvariantCulture));
            return new CredentialsRefreshState(loginToken.AccessToken, loginToken.AccessToken.ExpiresAt.Value);
        }
#else
        protected override CredentialsRefreshState GenerateNewCredentials()
        {
            return GenerateNewCredentialsAsync().ConfigureAwait(false).GetAwaiter().GetResult();
        }
#endif

        protected override async Task<CredentialsRefreshState> GenerateNewCredentialsAsync()
        {
            var loginTokenManagerGetTokenOptions = new LoginTokenManagerGetTokenOptions
            {
                LoginSession = Options.LoginSession,
                Region = Options.Region,
                ProxySettings = Options.ProxySettings
            };

            var loginToken = await _loginTokenManager.GetTokenAsync(loginTokenManagerGetTokenOptions).ConfigureAwait(false);
            if (loginToken == null)
            {
                throw new InvalidOperationException("Login Token not found. Please reauthenticate.");
            }

            _logger.DebugFormat("AWS Login credentials found that expire at {0}", loginToken.AccessToken.ExpiresAt.Value.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK", CultureInfo.InvariantCulture));
            return new CredentialsRefreshState(loginToken.AccessToken, loginToken.AccessToken.ExpiresAt.Value);
        }
    }
}
